{"version":3,"sources":["webpack:///kiva.min.js","webpack:///webpack/bootstrap 2defde1ffebd8e2999a4","webpack:///./src/kiva.js","webpack:///./src/kiva.parser.js","webpack:///./src/string.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","parser","kivaString","Kiva","get","rule","result","parse","dataType","type","peg$subclass","child","parent","ctor","this","constructor","prototype","peg$SyntaxError","message","expected","found","location","name","Error","captureStackTrace","peg$parse","input","peg$computePosDetails","pos","ch","details","peg$posDetailsCache","line","column","seenCR","charAt","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","start","offset","end","peg$fail","peg$maxFailPos","peg$currPos","peg$maxFailExpected","push","peg$buildException","cleanupExpected","i","sort","a","b","description","length","splice","buildMessage","stringEscape","s","hex","charCodeAt","toString","toUpperCase","replace","expectedDesc","foundDesc","expectedDescs","Array","slice","join","peg$parseStart","s0","peg$parseEmail","s1","s2","s3","s4","s5","s6","s7","s8","s9","substr","toLowerCase","peg$c0","peg$FAILED","peg$silentFails","peg$c1","peg$parse_","peg$parseRandomNumber","peg$c2","peg$c3","peg$parseRandomString","peg$savedPos","peg$c4","peg$parseNumber","peg$c5","peg$parseLetter","peg$c6","peg$c7","test","peg$c8","peg$c9","peg$c10","peg$parsews","peg$c12","peg$c13","peg$c11","peg$c14","peg$result","options","arguments","peg$startRuleFunctions","Start","peg$startRuleFunction","value","lp","dp","ds","localPartLen","domainPartLen","domainSuffix","n","parseInt","l","startRule","SyntaxError","KivaString","email"],"mappings":"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","file":"kiva.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author huntbao\n\t */\n\t'use strict'\n\t\n\tvar parser = __webpack_require__(1)\n\tvar kivaString = __webpack_require__(2)\n\t\n\tvar Kiva = {\n\t    get: function(rule) {\n\t        var result = parser.parse(rule)\n\t        switch (result.dataType) {\n\t            case 'string':\n\t                if (kivaString[result.type]) {\n\t                    return kivaString[result.type]()\n\t                }\n\t                break\n\t\n\t            default:\n\t                break\n\t        }\n\t    }\n\t}\n\t\n\tmodule.exports = Kiva\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = (function() {\n\t  \"use strict\";\n\t\n\t  /*\n\t   * Generated by PEG.js 0.9.0.\n\t   *\n\t   * http://pegjs.org/\n\t   */\n\t\n\t  function peg$subclass(child, parent) {\n\t    function ctor() { this.constructor = child; }\n\t    ctor.prototype = parent.prototype;\n\t    child.prototype = new ctor();\n\t  }\n\t\n\t  function peg$SyntaxError(message, expected, found, location) {\n\t    this.message  = message;\n\t    this.expected = expected;\n\t    this.found    = found;\n\t    this.location = location;\n\t    this.name     = \"SyntaxError\";\n\t\n\t    if (typeof Error.captureStackTrace === \"function\") {\n\t      Error.captureStackTrace(this, peg$SyntaxError);\n\t    }\n\t  }\n\t\n\t  peg$subclass(peg$SyntaxError, Error);\n\t\n\t  function peg$parse(input) {\n\t    var options = arguments.length > 1 ? arguments[1] : {},\n\t        parser  = this,\n\t\n\t        peg$FAILED = {},\n\t\n\t        peg$startRuleFunctions = { Start: peg$parseStart },\n\t        peg$startRuleFunction  = peg$parseStart,\n\t\n\t        peg$c0 = \"@s[email]\",\n\t        peg$c1 = { type: \"literal\", value: \"@S[email]\", description: \"\\\"@S[email]\\\"\" },\n\t        peg$c2 = \"-\",\n\t        peg$c3 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n\t        peg$c4 = function(lp, dp, ds) {\n\t                return {\n\t                    dataType: 'string',\n\t                    type: 'email',\n\t                    localPartLen: lp,\n\t                    domainPartLen: dp,\n\t                    domainSuffix: ds\n\t                }\n\t            },\n\t        peg$c5 = function(n) {\n\t                return parseInt(n.join(''));\n\t            },\n\t        peg$c6 = function(l) {\n\t                return l.join('');\n\t            },\n\t        peg$c7 = /^[0-9]/,\n\t        peg$c8 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n\t        peg$c9 = /^[a-zA-Z]/,\n\t        peg$c10 = { type: \"class\", value: \"[a-zA-Z]\", description: \"[a-zA-Z]\" },\n\t        peg$c11 = { type: \"other\", description: \"Whitespace\" },\n\t        peg$c12 = /^[ \\t]/,\n\t        peg$c13 = { type: \"class\", value: \"[ \\\\t]\", description: \"[ \\\\t]\" },\n\t        peg$c14 = { type: \"other\", description: \"Zero or more whitespaces\" },\n\t        peg$c15 = { type: \"other\", description: \"One or more whitespaces\" },\n\t\n\t        peg$currPos          = 0,\n\t        peg$savedPos         = 0,\n\t        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],\n\t        peg$maxFailPos       = 0,\n\t        peg$maxFailExpected  = [],\n\t        peg$silentFails      = 0,\n\t\n\t        peg$result;\n\t\n\t    if (\"startRule\" in options) {\n\t      if (!(options.startRule in peg$startRuleFunctions)) {\n\t        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n\t      }\n\t\n\t      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n\t    }\n\t\n\t    function text() {\n\t      return input.substring(peg$savedPos, peg$currPos);\n\t    }\n\t\n\t    function location() {\n\t      return peg$computeLocation(peg$savedPos, peg$currPos);\n\t    }\n\t\n\t    function expected(description) {\n\t      throw peg$buildException(\n\t        null,\n\t        [{ type: \"other\", description: description }],\n\t        input.substring(peg$savedPos, peg$currPos),\n\t        peg$computeLocation(peg$savedPos, peg$currPos)\n\t      );\n\t    }\n\t\n\t    function error(message) {\n\t      throw peg$buildException(\n\t        message,\n\t        null,\n\t        input.substring(peg$savedPos, peg$currPos),\n\t        peg$computeLocation(peg$savedPos, peg$currPos)\n\t      );\n\t    }\n\t\n\t    function peg$computePosDetails(pos) {\n\t      var details = peg$posDetailsCache[pos],\n\t          p, ch;\n\t\n\t      if (details) {\n\t        return details;\n\t      } else {\n\t        p = pos - 1;\n\t        while (!peg$posDetailsCache[p]) {\n\t          p--;\n\t        }\n\t\n\t        details = peg$posDetailsCache[p];\n\t        details = {\n\t          line:   details.line,\n\t          column: details.column,\n\t          seenCR: details.seenCR\n\t        };\n\t\n\t        while (p < pos) {\n\t          ch = input.charAt(p);\n\t          if (ch === \"\\n\") {\n\t            if (!details.seenCR) { details.line++; }\n\t            details.column = 1;\n\t            details.seenCR = false;\n\t          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n\t            details.line++;\n\t            details.column = 1;\n\t            details.seenCR = true;\n\t          } else {\n\t            details.column++;\n\t            details.seenCR = false;\n\t          }\n\t\n\t          p++;\n\t        }\n\t\n\t        peg$posDetailsCache[pos] = details;\n\t        return details;\n\t      }\n\t    }\n\t\n\t    function peg$computeLocation(startPos, endPos) {\n\t      var startPosDetails = peg$computePosDetails(startPos),\n\t          endPosDetails   = peg$computePosDetails(endPos);\n\t\n\t      return {\n\t        start: {\n\t          offset: startPos,\n\t          line:   startPosDetails.line,\n\t          column: startPosDetails.column\n\t        },\n\t        end: {\n\t          offset: endPos,\n\t          line:   endPosDetails.line,\n\t          column: endPosDetails.column\n\t        }\n\t      };\n\t    }\n\t\n\t    function peg$fail(expected) {\n\t      if (peg$currPos < peg$maxFailPos) { return; }\n\t\n\t      if (peg$currPos > peg$maxFailPos) {\n\t        peg$maxFailPos = peg$currPos;\n\t        peg$maxFailExpected = [];\n\t      }\n\t\n\t      peg$maxFailExpected.push(expected);\n\t    }\n\t\n\t    function peg$buildException(message, expected, found, location) {\n\t      function cleanupExpected(expected) {\n\t        var i = 1;\n\t\n\t        expected.sort(function(a, b) {\n\t          if (a.description < b.description) {\n\t            return -1;\n\t          } else if (a.description > b.description) {\n\t            return 1;\n\t          } else {\n\t            return 0;\n\t          }\n\t        });\n\t\n\t        while (i < expected.length) {\n\t          if (expected[i - 1] === expected[i]) {\n\t            expected.splice(i, 1);\n\t          } else {\n\t            i++;\n\t          }\n\t        }\n\t      }\n\t\n\t      function buildMessage(expected, found) {\n\t        function stringEscape(s) {\n\t          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\t\n\t          return s\n\t            .replace(/\\\\/g,   '\\\\\\\\')\n\t            .replace(/\"/g,    '\\\\\"')\n\t            .replace(/\\x08/g, '\\\\b')\n\t            .replace(/\\t/g,   '\\\\t')\n\t            .replace(/\\n/g,   '\\\\n')\n\t            .replace(/\\f/g,   '\\\\f')\n\t            .replace(/\\r/g,   '\\\\r')\n\t            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n\t            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n\t            .replace(/[\\u0100-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n\t            .replace(/[\\u1000-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n\t        }\n\t\n\t        var expectedDescs = new Array(expected.length),\n\t            expectedDesc, foundDesc, i;\n\t\n\t        for (i = 0; i < expected.length; i++) {\n\t          expectedDescs[i] = expected[i].description;\n\t        }\n\t\n\t        expectedDesc = expected.length > 1\n\t          ? expectedDescs.slice(0, -1).join(\", \")\n\t              + \" or \"\n\t              + expectedDescs[expected.length - 1]\n\t          : expectedDescs[0];\n\t\n\t        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\t\n\t        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n\t      }\n\t\n\t      if (expected !== null) {\n\t        cleanupExpected(expected);\n\t      }\n\t\n\t      return new peg$SyntaxError(\n\t        message !== null ? message : buildMessage(expected, found),\n\t        expected,\n\t        found,\n\t        location\n\t      );\n\t    }\n\t\n\t    function peg$parseStart() {\n\t      var s0;\n\t\n\t      s0 = peg$parseEmail();\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseEmail() {\n\t      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c0) {\n\t        s1 = input.substr(peg$currPos, 9);\n\t        peg$currPos += 9;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) { peg$fail(peg$c1); }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = peg$parse_();\n\t        if (s2 !== peg$FAILED) {\n\t          s3 = peg$parseRandomNumber();\n\t          if (s3 !== peg$FAILED) {\n\t            s4 = peg$parse_();\n\t            if (s4 !== peg$FAILED) {\n\t              s5 = [];\n\t              if (input.charCodeAt(peg$currPos) === 45) {\n\t                s6 = peg$c2;\n\t                peg$currPos++;\n\t              } else {\n\t                s6 = peg$FAILED;\n\t                if (peg$silentFails === 0) { peg$fail(peg$c3); }\n\t              }\n\t              while (s6 !== peg$FAILED) {\n\t                s5.push(s6);\n\t                if (input.charCodeAt(peg$currPos) === 45) {\n\t                  s6 = peg$c2;\n\t                  peg$currPos++;\n\t                } else {\n\t                  s6 = peg$FAILED;\n\t                  if (peg$silentFails === 0) { peg$fail(peg$c3); }\n\t                }\n\t              }\n\t              if (s5 !== peg$FAILED) {\n\t                s6 = peg$parse_();\n\t                if (s6 !== peg$FAILED) {\n\t                  s7 = peg$parseRandomNumber();\n\t                  if (s7 !== peg$FAILED) {\n\t                    s8 = peg$parse_();\n\t                    if (s8 !== peg$FAILED) {\n\t                      s9 = peg$parseRandomString();\n\t                      if (s9 !== peg$FAILED) {\n\t                        peg$savedPos = s0;\n\t                        s1 = peg$c4(s3, s7, s9);\n\t                        s0 = s1;\n\t                      } else {\n\t                        peg$currPos = s0;\n\t                        s0 = peg$FAILED;\n\t                      }\n\t                    } else {\n\t                      peg$currPos = s0;\n\t                      s0 = peg$FAILED;\n\t                    }\n\t                  } else {\n\t                    peg$currPos = s0;\n\t                    s0 = peg$FAILED;\n\t                  }\n\t                } else {\n\t                  peg$currPos = s0;\n\t                  s0 = peg$FAILED;\n\t                }\n\t              } else {\n\t                peg$currPos = s0;\n\t                s0 = peg$FAILED;\n\t              }\n\t            } else {\n\t              peg$currPos = s0;\n\t              s0 = peg$FAILED;\n\t            }\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$FAILED;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$FAILED;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$FAILED;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseRandomNumber() {\n\t      var s0, s1, s2;\n\t\n\t      s0 = peg$currPos;\n\t      s1 = [];\n\t      s2 = peg$parseNumber();\n\t      while (s2 !== peg$FAILED) {\n\t        s1.push(s2);\n\t        s2 = peg$parseNumber();\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        peg$savedPos = s0;\n\t        s1 = peg$c5(s1);\n\t      }\n\t      s0 = s1;\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseRandomString() {\n\t      var s0, s1, s2;\n\t\n\t      s0 = peg$currPos;\n\t      s1 = [];\n\t      s2 = peg$parseLetter();\n\t      while (s2 !== peg$FAILED) {\n\t        s1.push(s2);\n\t        s2 = peg$parseLetter();\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        peg$savedPos = s0;\n\t        s1 = peg$c6(s1);\n\t      }\n\t      s0 = s1;\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseWord() {\n\t      var s0, s1, s2;\n\t\n\t      s0 = peg$currPos;\n\t      s1 = [];\n\t      s2 = peg$parseLetter();\n\t      if (s2 !== peg$FAILED) {\n\t        while (s2 !== peg$FAILED) {\n\t          s1.push(s2);\n\t          s2 = peg$parseLetter();\n\t        }\n\t      } else {\n\t        s1 = peg$FAILED;\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        peg$savedPos = s0;\n\t        s1 = peg$c6(s1);\n\t      }\n\t      s0 = s1;\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseNumber() {\n\t      var s0;\n\t\n\t      if (peg$c7.test(input.charAt(peg$currPos))) {\n\t        s0 = input.charAt(peg$currPos);\n\t        peg$currPos++;\n\t      } else {\n\t        s0 = peg$FAILED;\n\t        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseLetter() {\n\t      var s0;\n\t\n\t      if (peg$c9.test(input.charAt(peg$currPos))) {\n\t        s0 = input.charAt(peg$currPos);\n\t        peg$currPos++;\n\t      } else {\n\t        s0 = peg$FAILED;\n\t        if (peg$silentFails === 0) { peg$fail(peg$c10); }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parsews() {\n\t      var s0, s1;\n\t\n\t      peg$silentFails++;\n\t      if (peg$c12.test(input.charAt(peg$currPos))) {\n\t        s0 = input.charAt(peg$currPos);\n\t        peg$currPos++;\n\t      } else {\n\t        s0 = peg$FAILED;\n\t        if (peg$silentFails === 0) { peg$fail(peg$c13); }\n\t      }\n\t      peg$silentFails--;\n\t      if (s0 === peg$FAILED) {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) { peg$fail(peg$c11); }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parse_() {\n\t      var s0, s1;\n\t\n\t      peg$silentFails++;\n\t      s0 = [];\n\t      s1 = peg$parsews();\n\t      while (s1 !== peg$FAILED) {\n\t        s0.push(s1);\n\t        s1 = peg$parsews();\n\t      }\n\t      peg$silentFails--;\n\t      if (s0 === peg$FAILED) {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) { peg$fail(peg$c14); }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parse__() {\n\t      var s0, s1;\n\t\n\t      peg$silentFails++;\n\t      s0 = [];\n\t      s1 = peg$parsews();\n\t      if (s1 !== peg$FAILED) {\n\t        while (s1 !== peg$FAILED) {\n\t          s0.push(s1);\n\t          s1 = peg$parsews();\n\t        }\n\t      } else {\n\t        s0 = peg$FAILED;\n\t      }\n\t      peg$silentFails--;\n\t      if (s0 === peg$FAILED) {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) { peg$fail(peg$c15); }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    peg$result = peg$startRuleFunction();\n\t\n\t    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n\t      return peg$result;\n\t    } else {\n\t      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n\t        peg$fail({ type: \"end\", description: \"end of input\" });\n\t      }\n\t\n\t      throw peg$buildException(\n\t        null,\n\t        peg$maxFailExpected,\n\t        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n\t        peg$maxFailPos < input.length\n\t          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n\t          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n\t      );\n\t    }\n\t  }\n\t\n\t  return {\n\t    SyntaxError: peg$SyntaxError,\n\t    parse:       peg$parse\n\t  };\n\t})();\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @author huntbao\n\t */\n\t\n\t'use strict'\n\t\n\tvar  KivaString = {\n\t\n\t    email: function (options) {\n\t        return 'just.for.test@gmail.com'\n\t    }\n\t}\n\t\n\tmodule.exports = KivaString\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** kiva.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2defde1ffebd8e2999a4\n **/","/**\n * @author huntbao\n */\n'use strict'\n\nvar parser = require('./kiva.parser')\nvar kivaString = require('./string')\n\nvar Kiva = {\n    get: function(rule) {\n        var result = parser.parse(rule)\n        switch (result.dataType) {\n            case 'string':\n                if (kivaString[result.type]) {\n                    return kivaString[result.type]()\n                }\n                break\n\n            default:\n                break\n        }\n    }\n}\n\nmodule.exports = Kiva\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/kiva.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = (function() {\n  \"use strict\";\n\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n        parser  = this,\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { Start: peg$parseStart },\n        peg$startRuleFunction  = peg$parseStart,\n\n        peg$c0 = \"@s[email]\",\n        peg$c1 = { type: \"literal\", value: \"@S[email]\", description: \"\\\"@S[email]\\\"\" },\n        peg$c2 = \"-\",\n        peg$c3 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n        peg$c4 = function(lp, dp, ds) {\n                return {\n                    dataType: 'string',\n                    type: 'email',\n                    localPartLen: lp,\n                    domainPartLen: dp,\n                    domainSuffix: ds\n                }\n            },\n        peg$c5 = function(n) {\n                return parseInt(n.join(''));\n            },\n        peg$c6 = function(l) {\n                return l.join('');\n            },\n        peg$c7 = /^[0-9]/,\n        peg$c8 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c9 = /^[a-zA-Z]/,\n        peg$c10 = { type: \"class\", value: \"[a-zA-Z]\", description: \"[a-zA-Z]\" },\n        peg$c11 = { type: \"other\", description: \"Whitespace\" },\n        peg$c12 = /^[ \\t]/,\n        peg$c13 = { type: \"class\", value: \"[ \\\\t]\", description: \"[ \\\\t]\" },\n        peg$c14 = { type: \"other\", description: \"Zero or more whitespaces\" },\n        peg$c15 = { type: \"other\", description: \"One or more whitespaces\" },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(\n        message,\n        null,\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n          p, ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0100-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1000-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parseStart() {\n      var s0;\n\n      s0 = peg$parseEmail();\n\n      return s0;\n    }\n\n    function peg$parseEmail() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c0) {\n        s1 = input.substr(peg$currPos, 9);\n        peg$currPos += 9;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c1); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseRandomNumber();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              if (input.charCodeAt(peg$currPos) === 45) {\n                s6 = peg$c2;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c3); }\n              }\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                if (input.charCodeAt(peg$currPos) === 45) {\n                  s6 = peg$c2;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c3); }\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseRandomNumber();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse_();\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parseRandomString();\n                      if (s9 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c4(s3, s7, s9);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseRandomNumber() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseNumber();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseNumber();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c5(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseRandomString() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseLetter();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseLetter();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseWord() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseLetter();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseLetter();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseNumber() {\n      var s0;\n\n      if (peg$c7.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseLetter() {\n      var s0;\n\n      if (peg$c9.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c10); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsews() {\n      var s0, s1;\n\n      peg$silentFails++;\n      if (peg$c12.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c13); }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c11); }\n      }\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = [];\n      s1 = peg$parsews();\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsews();\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c14); }\n      }\n\n      return s0;\n    }\n\n    function peg$parse__() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = [];\n      s1 = peg$parsews();\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          s1 = peg$parsews();\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c15); }\n      }\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(\n        null,\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/kiva.parser.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * @author huntbao\n */\n\n'use strict'\n\nvar  KivaString = {\n\n    email: function (options) {\n        return 'just.for.test@gmail.com'\n    }\n}\n\nmodule.exports = KivaString\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/string.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}